name: Single Instance Blue-Green Deployment (SSM)

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  AWS_REGION: ap-south-1
  BLUE_TG_ARN: ${{ secrets.BLUE_TARGET_GROUP_ARN }}
  GREEN_TG_ARN: ${{ secrets.GREEN_TARGET_GROUP_ARN }}
  ALB_LISTENER_ARN: ${{ secrets.ALB_LISTENER_ARN }}
  LAUNCH_TEMPLATE_ID: ${{ secrets.LAUNCH_TEMPLATE_ID }}
  PRIVATE_SUBNET_ID: ${{ secrets.PRIVATE_SUBNET_ID }}

jobs:
  build:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.set_tag.outputs.tag }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set image tag
        id: set_tag
        run: |
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          echo "tag=v${{ github.run_number }}-${SHORT_SHA}" >> $GITHUB_OUTPUT

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and push Database image
        uses: docker/build-push-action@v4
        with:
          context: ./db
          push: true
          tags: |
            ${{ secrets.DOCKER_USERNAME }}/quotes-db:${{ steps.set_tag.outputs.tag }}
            ${{ secrets.DOCKER_USERNAME }}/quotes-db:latest
          cache-from: type=registry,ref=${{ secrets.DOCKER_USERNAME }}/quotes-db:buildcache
          cache-to: type=registry,ref=${{ secrets.DOCKER_USERNAME }}/quotes-db:buildcache,mode=max

      - name: Build and push API image
        uses: docker/build-push-action@v4
        with:
          context: ./api
          push: true
          tags: |
            ${{ secrets.DOCKER_USERNAME }}/quotes-api:${{ steps.set_tag.outputs.tag }}
            ${{ secrets.DOCKER_USERNAME }}/quotes-api:latest
          cache-from: type=registry,ref=${{ secrets.DOCKER_USERNAME }}/quotes-api:buildcache
          cache-to: type=registry,ref=${{ secrets.DOCKER_USERNAME }}/quotes-api:buildcache,mode=max

      - name: Build and push Frontend image
        uses: docker/build-push-action@v4
        with:
          context: ./app
          push: true
          tags: |
            ${{ secrets.DOCKER_USERNAME }}/quotes-frontend:${{ steps.set_tag.outputs.tag }}
            ${{ secrets.DOCKER_USERNAME }}/quotes-frontend:latest
          cache-from: type=registry,ref=${{ secrets.DOCKER_USERNAME }}/quotes-frontend:buildcache
          cache-to: type=registry,ref=${{ secrets.DOCKER_USERNAME }}/quotes-frontend:buildcache,mode=max


  provision-green:
    name: Launch Green Instance
    needs: build
    runs-on: ubuntu-latest
    outputs:
      green_instance_id: ${{ steps.launch.outputs.instance_id }}

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Launch single green instance
        id: launch
        run: |
          echo "Launching new green instance..."

          INSTANCE_ID=$(aws ec2 run-instances \
            --launch-template LaunchTemplateId=${{ env.LAUNCH_TEMPLATE_ID }} \
            --count 1 \
            --subnet-id ${{ env.PRIVATE_SUBNET_ID }} \
            --tag-specifications "ResourceType=instance,Tags=[
              {Key=Environment,Value=green},
              {Key=Version,Value=${{ needs.build.outputs.image_tag }}},
              {Key=Name,Value=quotes-app-green}
            ]" \
            --query 'Instances[0].InstanceId' \
            --output text)

          echo "instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT
          echo "✅ Launched green instance: $INSTANCE_ID"

      - name: Wait for instance to be ready
        run: |
          echo "Waiting for instance to be running..."
          aws ec2 wait instance-running --instance-ids ${{ steps.launch.outputs.instance_id }}

          echo "Instance is running. Waiting for initialization to complete..."
          sleep 150

          echo "Checking SSM agent status..."
          for i in {1..30}; do
            STATUS=$(aws ssm describe-instance-information \
              --instance-information-filter-list "key=InstanceIds,valueSet=${{ steps.launch.outputs.instance_id }}" \
              --query 'InstanceInformationList[0].PingStatus' \
              --output text 2>/dev/null || echo "Offline")

            echo "Attempt $i/30 - SSM Agent Status: $STATUS"

            if [ "$STATUS" = "Online" ]; then
              echo "✅ SSM agent is online and ready"
              exit 0
            fi

            sleep 10
          done

          echo "⚠️ SSM agent status check timed out, but continuing..."


  deploy:
    name: Deploy Application to Green Instance via SSM
    needs: [build, provision-green]
    runs-on: ubuntu-latest

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Send deployment files to instance via SSM
        run: |
          echo "Creating temp directory on instance..."
          aws ssm send-command \
            --instance-ids "${{ needs.provision-green.outputs.green_instance_id }}" \
            --document-name "AWS-RunShellScript" \
            --comment "Prepare deployment directory" \
            --parameters 'commands=["mkdir -p /home/ubuntu/quotes-app/deployment /home/ubuntu/quotes-app/nginx-config"]' \
            --timeout-seconds 600

      - name: Upload deployment files to instance with SSM (using AWS-RunDocument or via base64 encoded scripts)
        run: |
          echo "Uploading deployment files (docker-compose.yml, nginx-config/, deployment/) to instance via SSM..."

          # Upload each file/directory by packaging, encoding, and running commands on the instance
          # Below is an example outline, actual implementation can be optimized or use `aws ssm send-command` multiple times.

          # Upload docker-compose.yml content
          DOCKER_COMPOSE_CONTENT=$(base64 -w 0 docker-compose.yml)
          aws ssm send-command \
            --instance-ids "${{ needs.provision-green.outputs.green_instance_id }}" \
            --document-name "AWS-RunShellScript" \
            --comment "Upload docker-compose.yml" \
            --parameters commands=["echo $DOCKER_COMPOSE_CONTENT | base64 -d > /home/ubuntu/quotes-app/docker-compose.yml"] \
            --timeout-seconds 600

          # For directories (nginx-config, deployment), compress and upload similarly or copy from a public bucket or use other secure means if allowed. 
          # Alternatively, you can use SSM to run wget or curl commands if files are hosted somewhere accessible.

          echo "✅ Deployment files uploaded."

      - name: Run deploy.sh script via SSM
        run: |
          echo "Running deploy.sh via SSM..."
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "${{ needs.provision-green.outputs.green_instance_id }}" \
            --document-name "AWS-RunShellScript" \
            --comment "Deploy quotes app ${{ needs.build.outputs.image_tag }}" \
            --timeout-seconds 1800 \
            --parameters 'commands=[
              "chmod +x /home/ubuntu/quotes-app/deployment/deploy.sh",
              "bash /home/ubuntu/quotes-app/deployment/deploy.sh ${{ secrets.DOCKER_USERNAME }} ${{ needs.build.outputs.image_tag }} ${{ secrets.DOCKER_PASSWORD }} green"
            ]' \
            --query 'Command.CommandId' \
            --output text)

          echo "Command ID: $COMMAND_ID"
          echo "Polling deployment status (max 15 minutes)..."

          MAX_ATTEMPTS=120
          ATTEMPT=0

          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))
            RESULT=$(aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "${{ needs.provision-green.outputs.green_instance_id }}" --region ${{ env.AWS_REGION }} 2>/dev/null || echo '{"Status":"Pending"}')
            STATUS=$(echo "$RESULT" | jq -r '.Status')
            echo "Attempt $ATTEMPT/$MAX_ATTEMPTS - Status: $STATUS - Time: $(date +%H:%M:%S)"
            if [ "$STATUS" = "Success" ]; then
              echo ""
              echo "✅ Deployment successful!"
              echo "$RESULT" | jq -r '.StandardOutputContent'
              exit 0
            fi
            if [ "$STATUS" = "Failed" ] || [ "$STATUS" = "TimedOut" ] || [ "$STATUS" = "Cancelled" ]; then
              echo ""
              echo "❌ Deployment failed with status: $STATUS"
              echo "$RESULT" | jq -r '.StandardOutputContent'
              echo "$RESULT" | jq -r '.StandardErrorContent'
              exit 1
            fi
            sleep 15
          done

          echo ""
          echo "❌ Deployment timeout after 15 minutes"
          exit 1



  health-check:
    name: Health Check
    needs: [provision-green, deploy]
    runs-on: ubuntu-latest

    steps:
      - uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Run health check
        run: |
          INSTANCE_ID=${{ needs.provision-green.outputs.green_instance_id }}
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=["cd /home/ubuntu/quotes-app && bash deployment/health_check.sh"]' \
            --query 'Command.CommandId' --output text)
          for i in {1..30}; do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --query 'Status' --output text 2>/dev/null || echo "Pending")
            echo "Attempt $i: $STATUS"
            if [ "$STATUS" = "Success" ]; then
              echo "Health check passed"
              exit 0
            fi
            if [[ "$STATUS" =~ ^(Failed|TimedOut)$ ]]; then
              echo "Health check failed"
              exit 1
            fi
            sleep 10
          done

  register-green:
    name: Register Green
    needs: [provision-green, health-check]
    runs-on: ubuntu-latest

    steps:
      - uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Register and wait for healthy
        run: |
          INSTANCE_ID=${{ needs.provision-green.outputs.green_instance_id }}
          aws elbv2 register-targets \
            --target-group-arn ${{ env.GREEN_TG_ARN }} \
            --targets Id=$INSTANCE_ID
          echo "Waiting for healthy status..."
          for i in {1..60}; do
            STATE=$(aws elbv2 describe-target-health \
              --target-group-arn ${{ env.GREEN_TG_ARN }} \
              --targets Id=$INSTANCE_ID \
              --query 'TargetHealthDescriptions[0].TargetHealth.State' \
              --output text)
            echo "[$i/60] $STATE"
            if [ "$STATE" = "healthy" ]; then
              echo "Target healthy"
              exit 0
            fi
            if [ "$STATE" = "unhealthy" ] && [ $i -gt 30 ]; then
              echo "Target unhealthy"
              exit 1
            fi
            sleep 15
          done

  configure-canary:
    name: Canary 20%
    needs: [provision-green, register-green]
    runs-on: ubuntu-latest

    steps:
      - uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Configure traffic split
        run: |
          aws elbv2 modify-listener \
            --listener-arn ${{ env.ALB_LISTENER_ARN }} \
            --default-actions Type=forward,ForwardConfig='{"TargetGroups":[{"TargetGroupArn":"'"${{ env.BLUE_TG_ARN }}"'","Weight":80},{"TargetGroupArn":"'"${{ env.GREEN_TG_ARN }}"'","Weight":20}]}'
          echo "Traffic: Blue 80%, Green 20%"

  approve:
    name: QA Approval
    needs: configure-canary
    runs-on: ubuntu-latest
    environment: production-approval

    steps:
      - run: echo "Awaiting QA approval"

  complete-deployment:
    name: Complete Deployment
    needs: [provision-green, approve]
    runs-on: ubuntu-latest

    steps:
      - uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get blue instance
        id: blue
        run: |
          BLUE_ID=$(aws ec2 describe-instances \
            --filters "Name=tag:Environment,Values=blue" "Name=instance-state-name,Values=running" \
            --query 'Reservations[0].Instances[0].InstanceId' --output text 2>/dev/null || echo "")
          echo "blue_id=$BLUE_ID" >> $GITHUB_OUTPUT

      - name: Route 100% to green
        run: |
          aws elbv2 modify-listener \
            --listener-arn ${{ env.ALB_LISTENER_ARN }} \
            --default-actions Type=forward,TargetGroupArn=${{ env.GREEN_TG_ARN }}
          echo "Waiting for traffic to stabilize..."
          sleep 45

      - name: Cleanup blue instance
        if: steps.blue.outputs.blue_id != '' && steps.blue.outputs.blue_id != 'None'
        run: |
          aws elbv2 deregister-targets \
            --target-group-arn ${{ env.BLUE_TG_ARN }} \
            --targets Id=${{ steps.blue.outputs.blue_id }}
          sleep 60
          aws ec2 terminate-instances --instance-ids ${{ steps.blue.outputs.blue_id }}

      - name: Promote green to blue
        run: |
          INSTANCE_ID=${{ needs.provision-green.outputs.green_instance_id }}
          aws ec2 create-tags \
            --resources $INSTANCE_ID \
            --tags Key=Environment,Value=blue Key=Name,Value=quotes-app-blue
          aws elbv2 register-targets \
            --target-group-arn ${{ env.BLUE_TG_ARN }} \
            --targets Id=$INSTANCE_ID
          sleep 30
          aws elbv2 modify-listener \
            --listener-arn ${{ env.ALB_LISTENER_ARN }} \
            --default-actions Type=forward,TargetGroupArn=${{ env.BLUE_TG_ARN }}
          sleep 15
          aws elbv2 deregister-targets \
            --target-group-arn ${{ env.GREEN_TG_ARN }} \
            --targets Id=$INSTANCE_ID
          echo "Deployment complete"
