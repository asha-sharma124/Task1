name: Progressive Rolling Deployment with Detailed Monitoring

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  AWS_REGION: ap-south-1
  OLD_TG_ARN: ${{ secrets.BLUE_TARGET_GROUP_ARN }}
  NEW_TG_ARN: ${{ secrets.GREEN_TARGET_GROUP_ARN }}
  ALB_LISTENER_ARN: ${{ secrets.ALB_LISTENER_ARN }}
  LAUNCH_TEMPLATE_ID: ${{ secrets.LAUNCH_TEMPLATE_ID }}
  PRIVATE_SUBNET_ID: ${{ secrets.PRIVATE_SUBNET_ID }}

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.set_tag.outputs.image_tag }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set image tag
        id: set_tag
        run: |
          TAG=$(date +'%Y%m%d%H%M%S')-${GITHUB_SHA::7}
          echo "image_tag=$TAG" >> $GITHUB_OUTPUT

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and push Docker images
        run: |
          TAG=${{ steps.set_tag.outputs.image_tag }}
          for service in db api app; do
            IMAGE_NAME="${{ secrets.DOCKER_USERNAME }}/quotes-${service}"
            docker build -t $IMAGE_NAME:${TAG} -t $IMAGE_NAME:latest $GITHUB_WORKSPACE/$service
            docker push $IMAGE_NAME:${TAG}
            docker push $IMAGE_NAME:latest
          done

      - name: Configure AWS and upload deployment files
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        run: |
          TAG=${{ steps.set_tag.outputs.image_tag }}
          sed -i "s|build: ./db|image: ${{ secrets.DOCKER_USERNAME }}/quotes-db:${TAG}|g" docker-compose.yml
          sed -i "s|build: ./api|image: ${{ secrets.DOCKER_USERNAME }}/quotes-api:${TAG}|g" docker-compose.yml
          sed -i "s|build: ./app|image: ${{ secrets.DOCKER_USERNAME }}/quotes-app:${TAG}|g" docker-compose.yml
          
          aws s3 cp docker-compose.yml s3://${{ secrets.DEPLOYMENT_BUCKET }}/deployments/${TAG}/
          aws s3 cp deployment/ s3://${{ secrets.DEPLOYMENT_BUCKET }}/deployments/${TAG}/deployment/ --recursive
          aws s3 cp ./nginx-config/quotes.conf s3://${{ secrets.DEPLOYMENT_BUCKET }}/deployments/${TAG}/

  create-launch-template:
    needs: build
    runs-on: ubuntu-latest
    outputs:
      template_version: ${{ steps.create.outputs.version }}
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Create launch template version with checkpoints
        id: create
        run: |
          TAG=${{ needs.build.outputs.image_tag }}
          
          cat > user-data.sh << 'USERDATA'
          #!/bin/bash
          set -ex
          exec > >(tee -a /var/log/user-data.log) 2>&1
          
          # CHECKPOINT 1: Script started
          echo "=== [CHECKPOINT 1/12] Starting deployment at $(date) ==="
          echo "checkpoint-1-started" > /tmp/checkpoint-1
          
          # Wait for cloud-init
          cloud-init status --wait || true
          echo "checkpoint-1-complete" > /tmp/checkpoint-1
          
          # CHECKPOINT 2: System update
          echo "=== [CHECKPOINT 2/12] Updating system at $(date) ==="
          echo "checkpoint-2-started" > /tmp/checkpoint-2
          export DEBIAN_FRONTEND=noninteractive
          apt-get update -y
          echo "checkpoint-2-complete" > /tmp/checkpoint-2
          
          # CHECKPOINT 3: Base packages
          echo "=== [CHECKPOINT 3/12] Installing base packages at $(date) ==="
          echo "checkpoint-3-started" > /tmp/checkpoint-3
          apt-get install -y curl wget unzip ca-certificates gnupg lsb-release nginx jq git
          echo "checkpoint-3-complete" > /tmp/checkpoint-3
          
          # CHECKPOINT 4: AWS CLI
          echo "=== [CHECKPOINT 4/12] Installing AWS CLI at $(date) ==="
          echo "checkpoint-4-started" > /tmp/checkpoint-4
          cd /tmp
          curl -s "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
          unzip -q awscliv2.zip
          ./aws/install
          rm -rf aws awscliv2.zip
          aws --version
          echo "checkpoint-4-complete: $(aws --version)" > /tmp/checkpoint-4
          
          # CHECKPOINT 5: Docker
          echo "=== [CHECKPOINT 5/12] Installing Docker at $(date) ==="
          echo "checkpoint-5-started" > /tmp/checkpoint-5
          curl -fsSL https://get.docker.com -o get-docker.sh
          sh get-docker.sh
          systemctl enable docker
          systemctl start docker
          rm get-docker.sh
          docker --version
          echo "checkpoint-5-complete: $(docker --version)" > /tmp/checkpoint-5
          
          # CHECKPOINT 6: Docker Compose
          echo "=== [CHECKPOINT 6/12] Installing Docker Compose at $(date) ==="
          echo "checkpoint-6-started" > /tmp/checkpoint-6
          COMPOSE_VERSION=$(curl -s https://api.github.com/repos/docker/compose/releases/latest | grep 'tag_name' | cut -d'"' -f4)
          curl -sL "https://github.com/docker/compose/releases/download/${COMPOSE_VERSION}/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
          chmod +x /usr/local/bin/docker-compose
          ln -sf /usr/local/bin/docker-compose /usr/bin/docker-compose
          docker-compose --version
          echo "checkpoint-6-complete: $(docker-compose --version)" > /tmp/checkpoint-6
          
          # CHECKPOINT 7: SSM Agent
          echo "=== [CHECKPOINT 7/12] Installing SSM Agent at $(date) ==="
          echo "checkpoint-7-started" > /tmp/checkpoint-7
          snap install amazon-ssm-agent --classic || {
              cd /tmp
              wget https://s3.amazonaws.com/ec2-downloads-windows/SSMAgent/latest/debian_amd64/amazon-ssm-agent.deb
              dpkg -i amazon-ssm-agent.deb
              rm amazon-ssm-agent.deb
          }
          systemctl enable snap.amazon-ssm-agent.amazon-ssm-agent.service || systemctl enable amazon-ssm-agent
          systemctl start snap.amazon-ssm-agent.amazon-ssm-agent.service || systemctl start amazon-ssm-agent
          echo "checkpoint-7-complete" > /tmp/checkpoint-7
          
          # CHECKPOINT 8: Configure environment
          echo "=== [CHECKPOINT 8/12] Configuring environment at $(date) ==="
          echo "checkpoint-8-started" > /tmp/checkpoint-8
          usermod -aG docker ubuntu
          mkdir -p /home/ubuntu/quotes-app/deployment
          chown -R ubuntu:ubuntu /home/ubuntu/quotes-app
          systemctl enable nginx
          systemctl start nginx
          rm -f /etc/nginx/sites-enabled/default
          echo "checkpoint-8-complete" > /tmp/checkpoint-8
          
          # CHECKPOINT 9: Pre-pull images
          echo "=== [CHECKPOINT 9/12] Pre-pulling Docker images at $(date) ==="
          echo "checkpoint-9-started" > /tmp/checkpoint-9
          echo "DOCKER_PASS" | docker login -u "DOCKER_USER" --password-stdin
          docker pull DOCKER_USER/quotes-db:latest &
          docker pull DOCKER_USER/quotes-api:latest &
          docker pull DOCKER_USER/quotes-app:latest &
          wait
          docker logout
          docker images
          echo "checkpoint-9-complete" > /tmp/checkpoint-9
          
          # CHECKPOINT 10: Download from S3
          echo "=== [CHECKPOINT 10/12] Downloading from S3 at $(date) ==="
          echo "checkpoint-10-started" > /tmp/checkpoint-10
          cd /home/ubuntu/quotes-app
          aws s3 cp s3://DEPLOYMENT_BUCKET/deployments/DEPLOYMENT_TAG/docker-compose.yml . || { echo "Failed docker-compose.yml"; exit 1; }
          aws s3 cp s3://DEPLOYMENT_BUCKET/deployments/DEPLOYMENT_TAG/deployment/ ./deployment/ --recursive || { echo "Failed deployment/"; exit 1; }
          aws s3 cp s3://DEPLOYMENT_BUCKET/deployments/DEPLOYMENT_TAG/quotes.conf . || { echo "Failed quotes.conf"; exit 1; }
          ls -la
          echo "checkpoint-10-complete" > /tmp/checkpoint-10
          
          # CHECKPOINT 11: Run deployment
          echo "=== [CHECKPOINT 11/12] Running deployment script at $(date) ==="
          echo "checkpoint-11-started" > /tmp/checkpoint-11
          chmod +x deployment/*.sh
          bash deployment/deploy.sh DOCKER_USER DEPLOYMENT_TAG DOCKER_PASS production || { echo "deploy.sh failed"; exit 1; }
          echo "checkpoint-11-complete" > /tmp/checkpoint-11
          
          # CHECKPOINT 12: Configure Nginx
          echo "=== [CHECKPOINT 12/12] Configuring Nginx at $(date) ==="
          echo "checkpoint-12-started" > /tmp/checkpoint-12
          if [ -f quotes.conf ]; then
            cp quotes.conf /etc/nginx/sites-available/quotes.conf
            ln -sf /etc/nginx/sites-available/quotes.conf /etc/nginx/sites-enabled/quotes.conf
            nginx -t && systemctl reload nginx
          fi
          echo "checkpoint-12-complete" > /tmp/checkpoint-12
          
          # Final verification
          echo "=== Verifying deployment ==="
          docker ps -a
          sleep 10
          curl -s http://localhost:80 && echo "✅ App responding" || echo "⚠️  App not responding"
          
          # Success marker
          echo "deployment_complete_$(date +%s)" > /tmp/deployment-complete
          
          echo "=== ✅ ALL CHECKPOINTS PASSED - Deployment completed at $(date) ==="
          USERDATA
          
          # Replace placeholders
          sed -i "s|DEPLOYMENT_BUCKET|${{ secrets.DEPLOYMENT_BUCKET }}|g" user-data.sh
          sed -i "s|DEPLOYMENT_TAG|${TAG}|g" user-data.sh
          sed -i "s|DOCKER_USER|${{ secrets.DOCKER_USERNAME }}|g" user-data.sh
          sed -i "s|DOCKER_PASS|${{ secrets.DOCKER_PASSWORD }}|g" user-data.sh
          
          # Verify replacements
          if grep -q "DEPLOYMENT_BUCKET\|DEPLOYMENT_TAG\|DOCKER_USER\|DOCKER_PASS" user-data.sh; then
            echo "❌ Placeholders still exist!"
            exit 1
          fi
          
          # Create template
          USER_DATA_B64=$(base64 -w 0 user-data.sh)
          VERSION=$(aws ec2 create-launch-template-version \
            --launch-template-id ${{ env.LAUNCH_TEMPLATE_ID }} \
            --source-version '$Latest' \
            --launch-template-data "{\"UserData\":\"${USER_DATA_B64}\"}" \
            --version-description "Deploy ${TAG}" \
            --query 'LaunchTemplateVersion.VersionNumber' \
            --output text)
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "✅ Created template version: $VERSION"

  get-old-instances:
    needs: create-launch-template
    runs-on: ubuntu-latest
    outputs:
      instance_ids: ${{ steps.get.outputs.ids }}
      count: ${{ steps.get.outputs.count }}
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get old instances
        id: get
        run: |
          INSTANCES=$(aws elbv2 describe-target-health \
            --target-group-arn ${{ env.OLD_TG_ARN }} \
            --query 'TargetHealthDescriptions[?TargetHealth.State==`healthy`].Target.Id' \
            --output json | jq -c .)
          
          COUNT=$(echo "$INSTANCES" | jq '. | length')
          
          echo "ids=$INSTANCES" >> $GITHUB_OUTPUT
          echo "count=$COUNT" >> $GITHUB_OUTPUT
          echo "✅ Found $COUNT instances"

  deploy-instance-1:
    needs: [build, create-launch-template]
    runs-on: ubuntu-latest
    outputs:
      instance_id: ${{ steps.deploy.outputs.id }}
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy first instance with detailed monitoring
        id: deploy
        run: |
          echo "=== Deploying Instance 1 ==="
          
          INSTANCE_ID=$(aws ec2 run-instances \
            --launch-template LaunchTemplateId=${{ env.LAUNCH_TEMPLATE_ID }},Version=${{ needs.create-launch-template.outputs.template_version }} \
            --subnet-id ${{ env.PRIVATE_SUBNET_ID }} \
            --tag-specifications "ResourceType=instance,Tags=[{Key=Name,Value=quotes-new-1}]" \
            --query 'Instances[0].InstanceId' \
            --output text)
          
          echo "id=$INSTANCE_ID" >> $GITHUB_OUTPUT
          echo "✅ Launched: $INSTANCE_ID"
          
          # Wait for running
          aws ec2 wait instance-running --instance-ids $INSTANCE_ID
          echo "Instance is running, waiting for user-data execution..."
          
          # Initial wait for SSM
          sleep 120
          
          # Monitor checkpoints
          echo "=== Monitoring Installation Progress ==="
          for i in {1..60}; do
            echo ""
            echo "--- Check $i/60 at $(date) ---"
            
            # Check checkpoint status
            CMD=$(aws ssm send-command \
              --instance-ids "$INSTANCE_ID" \
              --document-name "AWS-RunShellScript" \
              --parameters 'commands=[
                "echo === CHECKPOINT STATUS ===",
                "ls -1 /tmp/checkpoint-* 2>/dev/null | wc -l | xargs echo Completed checkpoints:",
                "echo",
                "echo === CHECKPOINT DETAILS ===",
                "for f in /tmp/checkpoint-*; do echo \"$f: $(cat $f 2>/dev/null)\"; done 2>/dev/null || echo No checkpoints yet",
                "echo",
                "echo === RECENT LOG (last 15 lines) ===",
                "tail -15 /var/log/user-data.log 2>/dev/null || echo No log yet",
                "echo",
                "echo === PROCESS CHECK ===",
                "ps aux | grep -E \"apt-get|docker|curl|aws\" | grep -v grep | head -5 || echo No relevant processes"
              ]' \
              --query 'Command.CommandId' \
              --output text 2>/dev/null || echo "")
            
            if [ -n "$CMD" ]; then
              sleep 10
              
              OUTPUT=$(aws ssm get-command-invocation \
                --command-id "$CMD" \
                --instance-id "$INSTANCE_ID" \
                --query 'StandardOutputContent' \
                --output text 2>/dev/null || echo "Cannot fetch yet")
              
              echo "$OUTPUT"
              
              # Check if complete
              if echo "$OUTPUT" | grep -q "deployment_complete"; then
                echo ""
                echo "✅✅✅ DEPLOYMENT COMPLETE ✅✅✅"
                break
              fi
              
              # Check checkpoint count
              CHECKPOINT_COUNT=$(echo "$OUTPUT" | grep "Completed checkpoints:" | grep -oE '[0-9]+' || echo "0")
              echo "Progress: $CHECKPOINT_COUNT/12 checkpoints"
            else
              echo "SSM not ready yet..."
            fi
            
            if [ $i -eq 60 ]; then
              echo ""
              echo "❌❌❌ TIMEOUT AFTER 30 MINUTES ❌❌❌"
              echo "Fetching final logs..."
              
              FINAL_CMD=$(aws ssm send-command \
                --instance-ids "$INSTANCE_ID" \
                --document-name "AWS-RunShellScript" \
                --parameters 'commands=["cat /var/log/user-data.log"]' \
                --query 'Command.CommandId' \
                --output text)
              
              sleep 10
              
              aws ssm get-command-invocation \
                --command-id "$FINAL_CMD" \
                --instance-id "$INSTANCE_ID" \
                --query 'StandardOutputContent' \
                --output text || echo "Cannot fetch logs"
              
              aws ec2 terminate-instances --instance-ids $INSTANCE_ID
              exit 1
            fi
            
            sleep 30
          done
          
          # Health check
          echo ""
          echo "=== Final Health Check ==="
          sleep 20
          
          HEALTH_CMD=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=["curl -s -o /dev/null -w \"%{http_code}\" http://localhost:80 2>/dev/null || echo 000"]' \
            --query 'Command.CommandId' \
            --output text)
          
          sleep 15
          
          STATUS=$(aws ssm get-command-invocation \
            --command-id "$HEALTH_CMD" \
            --instance-id "$INSTANCE_ID" \
            --query 'StandardOutputContent' \
            --output text | tr -cd '0-9' | head -c 3)
          
          echo "HTTP Status: ${STATUS:-000}"
          
          if [ "$STATUS" != "200" ]; then
            echo "❌ Health check failed"
            aws ec2 terminate-instances --instance-ids $INSTANCE_ID
            exit 1
          fi
          
          echo "✅ Health check passed!"
          
          # Register to target group
          aws elbv2 register-targets --target-group-arn ${{ env.NEW_TG_ARN }} --targets Id=$INSTANCE_ID
          sleep 60
          
          # Set traffic split
          aws elbv2 modify-listener --listener-arn ${{ env.ALB_LISTENER_ARN }} \
            --default-actions Type=forward,ForwardConfig="{
              TargetGroups=[
                {TargetGroupArn=${{ env.OLD_TG_ARN }},Weight=80},
                {TargetGroupArn=${{ env.NEW_TG_ARN }},Weight=20}
              ]
            }"
          
          echo "✅✅✅ INSTANCE 1 DEPLOYED SUCCESSFULLY ✅✅✅"

  deploy-remaining-instances:
    needs: [deploy-instance-1, get-old-instances, create-launch-template, build]
    runs-on: ubuntu-latest
    strategy:
      max-parallel: 1
      matrix:
        instance: [2, 3, 4]
    environment:
      name: wait-timer
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy instance ${{ matrix.instance }}
        run: |
          INSTANCE_NUM=${{ matrix.instance }}
          OLD_INDEX=$((INSTANCE_NUM - 2))
          
          echo "=== Deploying Instance $INSTANCE_NUM ==="
          
          OLD_INSTANCE=$(echo '${{ needs.get-old-instances.outputs.instance_ids }}' | jq -r ".[$OLD_INDEX]")
          
          NEW_INSTANCE=$(aws ec2 run-instances \
            --launch-template LaunchTemplateId=${{ env.LAUNCH_TEMPLATE_ID }},Version=${{ needs.create-launch-template.outputs.template_version }} \
            --subnet-id ${{ env.PRIVATE_SUBNET_ID }} \
            --tag-specifications "ResourceType=instance,Tags=[{Key=Name,Value=quotes-new-$INSTANCE_NUM}]" \
            --query 'Instances[0].InstanceId' --output text)
          
          echo "✅ Launched: $NEW_INSTANCE"
          
          aws ec2 wait instance-running --instance-ids $NEW_INSTANCE
          sleep 120
          
          # Monitor deployment
          for i in {1..60}; do
            CMD=$(aws ssm send-command \
              --instance-ids "$NEW_INSTANCE" \
              --document-name "AWS-RunShellScript" \
              --parameters 'commands=["ls -1 /tmp/checkpoint-* 2>/dev/null | wc -l"]' \
              --query 'Command.CommandId' \
              --output text 2>/dev/null || echo "")
            
            [ -z "$CMD" ] && { sleep 30; continue; }
            
            sleep 10
            
            COUNT=$(aws ssm get-command-invocation \
              --command-id "$CMD" \
              --instance-id "$NEW_INSTANCE" \
              --query 'StandardOutputContent' \
              --output text | tr -d '\n\r ')
            
            echo "Checkpoints: $COUNT/12"
            
            [ "$COUNT" = "12" ] && break
            
            if [ $i -eq 60 ]; then
              echo "❌ Timeout"
              aws ec2 terminate-instances --instance-ids $NEW_INSTANCE
              exit 1
            fi
            
            sleep 30
          done
          
          # Health check
          sleep 20
          HEALTH_CMD=$(aws ssm send-command \
            --instance-ids "$NEW_INSTANCE" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=["curl -s -o /dev/null -w \"%{http_code}\" http://localhost:80"]' \
            --query 'Command.CommandId' --output text)
          
          sleep 15
          
          HTTP_STATUS=$(aws ssm get-command-invocation \
            --command-id "$HEALTH_CMD" \
            --instance-id "$NEW_INSTANCE" \
            --query 'StandardOutputContent' \
            --output text | tr -cd '0-9' | head -c 3)
          
          if [ "$HTTP_STATUS" != "200" ]; then
            echo "❌ Failed"
            aws ec2 terminate-instances --instance-ids $NEW_INSTANCE
            exit 1
          fi
          
          echo "✅ Healthy"
          
          # Replace old instance
          aws elbv2 register-targets --target-group-arn ${{ env.NEW_TG_ARN }} --targets Id=$NEW_INSTANCE
          sleep 30
          aws elbv2 deregister-targets --target-group-arn ${{ env.OLD_TG_ARN }} --targets Id=$OLD_INSTANCE
          sleep 30
          aws ec2 terminate-instances --instance-ids $OLD_INSTANCE
          
          # Update traffic
          NEW_COUNT=$INSTANCE_NUM
          OLD_COUNT=$((4 - INSTANCE_NUM))
          
          if [ $OLD_COUNT -gt 0 ]; then
            NEW_WEIGHT=$(( (NEW_COUNT * 100) / (NEW_COUNT + OLD_COUNT) ))
            OLD_WEIGHT=$((100 - NEW_WEIGHT))
            
            aws elbv2 modify-listener --listener-arn ${{ env.ALB_LISTENER_ARN }} \
              --default-actions Type=forward,ForwardConfig="{
                TargetGroups=[
                  {TargetGroupArn=${{ env.OLD_TG_ARN }},Weight=$OLD_WEIGHT},
                  {TargetGroupArn=${{ env.NEW_TG_ARN }},Weight=$NEW_WEIGHT}
                ]
              }"
          fi
          
          echo "✅ Instance $INSTANCE_NUM deployed"

  finalize:
    needs: [deploy-remaining-instances, create-launch-template]
    runs-on: ubuntu-latest
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Finalize deployment
        run: |
          aws elbv2 modify-listener --listener-arn ${{ env.ALB_LISTENER_ARN }} \
            --default-actions Type=forward,TargetGroupArn=${{ env.NEW_TG_ARN }}
          
          aws ec2 modify-launch-template \
            --launch-template-id ${{ env.LAUNCH_TEMPLATE_ID }} \
            --default-version ${{ needs.create-launch-template.outputs.template_version }}
          
          echo "✅✅✅ DEPLOYMENT COMPLETE ✅✅✅"
