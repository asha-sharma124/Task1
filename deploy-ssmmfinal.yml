# name: Production Blue-Green Rolling Deployment
# on:
#   push:
#     branches: [main]
#   workflow_dispatch:
# env:
#   AWS_REGION: ap-south-1
#   BLUE_TG_ARN: ${{ secrets.BLUE_TARGET_GROUP_ARN }}
#   GREEN_TG_ARN: ${{ secrets.GREEN_TARGET_GROUP_ARN }}
#   ALB_LISTENER_ARN: ${{ secrets.ALB_LISTENER_ARN }}
#   LAUNCH_TEMPLATE_ID: ${{ secrets.LAUNCH_TEMPLATE_ID }}
#   PRIVATE_SUBNET_ID: ${{ secrets.PRIVATE_SUBNET_ID }}
#   DEPLOYMENT_BUCKET: ${{ secrets.DEPLOYMENT_BUCKET }}
#   TOTAL_INSTANCES: 4
#   WAIT_MINUTES: 1

# jobs:
#   build:
#     runs-on: ubuntu-latest
#     outputs:
#       image_tag: ${{ steps.set_tag.outputs.image_tag }}
#       initial_blue_count: ${{ steps.count.outputs.blue_count }}
#     steps:
#       - name: Checkout code
#         uses: actions/checkout@v3

#       - name: Set image tag
#         id: set_tag
#         run: |
#           TAG=$(date +'%Y%m%d%H%M%S')
#           echo "image_tag=$TAG" >> $GITHUB_OUTPUT
         
#       - name: Set up Docker Buildx
#         uses: docker/setup-buildx-action@v2

#       - name: Login to Docker Hub
#         uses: docker/login-action@v2
#         with:
#           username: ${{ secrets.DOCKER_USERNAME }}
#           password: ${{ secrets.DOCKER_PASSWORD }}

#       - name: Build and push Docker images
#         run: |
#           TAG=${{ steps.set_tag.outputs.image_tag }}
#           echo "Building images with tag: $TAG"
          
#           for service in db api app; do
#             IMAGE_NAME="${{ secrets.DOCKER_USERNAME }}/quotes-${service}"
#             echo "Building $service..."
#             docker build --no-cache -t $IMAGE_NAME:${TAG} -t $IMAGE_NAME:latest $GITHUB_WORKSPACE/$service
#             docker push $IMAGE_NAME:${TAG}
#             docker push $IMAGE_NAME:latest
           
#           done

#       - name: Configure AWS credentials
#         uses: aws-actions/configure-aws-credentials@v2
#         with:
#           aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
#           aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
#           aws-region: ${{ env.AWS_REGION }}

#       - name: Upload deployment files to S3
#         run: |
#           TAG=${{ steps.set_tag.outputs.image_tag }}
          
#           sed -i "s|build: ./db|image: ${{ secrets.DOCKER_USERNAME }}/quotes-db:${TAG}|g" docker-compose.yml
#           sed -i "s|build: ./api|image: ${{ secrets.DOCKER_USERNAME }}/quotes-api:${TAG}|g" docker-compose.yml
#           sed -i "s|build: ./app|image: ${{ secrets.DOCKER_USERNAME }}/quotes-app:${TAG}|g" docker-compose.yml

#           aws s3 cp docker-compose.yml s3://${DEPLOYMENT_BUCKET}/deployments/${TAG}/
#           aws s3 cp deployment/ s3://${DEPLOYMENT_BUCKET}/deployments/${TAG}/deployment/ --recursive
#           aws s3 cp ./nginx-config/quotes.conf s3://${DEPLOYMENT_BUCKET}/deployments/${TAG}/

#           echo " Deployment files uploaded to S3"

#       - name: Count current blue instances
#         id: count
#         run: |
#           # Fetch instance count from Blue Target Group
#           BLUE_COUNT=$(aws elbv2 describe-target-health \
#             --target-group-arn ${{ env.BLUE_TG_ARN }} \
#             --query 'length(TargetHealthDescriptions[])' \
#             --output text)
          
#           echo "blue_count=${BLUE_COUNT:-0}" >> $GITHUB_OUTPUT
#           echo "Current blue instances in TG: ${BLUE_COUNT:-0}"

#   deploy-first-instance:
#     needs: build
#     runs-on: ubuntu-latest
#     outputs:
#       green_instance_1: ${{ steps.launch.outputs.instance_id }}
#     steps:
#       - name: Configure AWS credentials
#         uses: aws-actions/configure-aws-credentials@v2
#         with:
#           aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
#           aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
#           aws-region: ${{ env.AWS_REGION }}

#       - name: Launch first green instance
#         id: launch
#         run: |
#           echo "ðŸš€ Launching Green Instance 1/${{ env.TOTAL_INSTANCES }}"
          
#           INSTANCE_ID=$(aws ec2 run-instances \
#             --launch-template LaunchTemplateId=${{ env.LAUNCH_TEMPLATE_ID }} \
#             --count 1 \
#             --subnet-id ${{ env.PRIVATE_SUBNET_ID }} \
#             --tag-specifications "ResourceType=instance,Tags=[
#               {Key=Name,Value=quotes-app-green-1},
#               {Key=Environment,Value=green},
#               {Key=DeploymentBatch,Value=${{ needs.build.outputs.image_tag }}},
#               {Key=InstanceNumber,Value=1}
#             ]" \
#             --query 'Instances[0].InstanceId' \
#             --output text)
          
#           echo "instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT
#           echo " Launched: $INSTANCE_ID"

#       - name: Wait for instance to be ready
#         run: |
#           echo "â³ Waiting for instance to be running..."
#           aws ec2 wait instance-running --instance-ids ${{ steps.launch.outputs.instance_id }}
          
#           echo "â³ Waiting for status checks..."
#           aws ec2 wait instance-status-ok --instance-ids ${{ steps.launch.outputs.instance_id }}
          
#           echo " Instance is ready"
#           sleep 20


     

#       - name: Deploy application
#         id: deploy
#         run: |
#           echo " Deploying application..."
          
#           COMMAND_ID=$(aws ssm send-command \
#             --instance-ids "${{ steps.launch.outputs.instance_id }}" \
#             --document-name "AWS-RunShellScript" \
#             --comment "Deploy ${{ needs.build.outputs.image_tag }} - Instance 1" \
#             --timeout-seconds 1800 \
#             --parameters 'commands=[
#               "#!/bin/bash",
#               "set -ex",
#               "sudo mkdir -p /home/ubuntu/quotes-app/deployment",
#               "sudo chown -R ubuntu:ubuntu /home/ubuntu/quotes-app",
#               "cd /home/ubuntu/quotes-app",
#               "aws s3 cp s3://${{ env.DEPLOYMENT_BUCKET }}/deployments/${{ needs.build.outputs.image_tag }}/docker-compose.yml . --region ${{ env.AWS_REGION }}",
#               "aws s3 cp s3://${{ env.DEPLOYMENT_BUCKET }}/deployments/${{ needs.build.outputs.image_tag }}/deployment/ ./deployment/ --recursive --region ${{ env.AWS_REGION }}",
#               "aws s3 cp s3://${{ env.DEPLOYMENT_BUCKET }}/deployments/${{ needs.build.outputs.image_tag }}/quotes.conf . --region ${{ env.AWS_REGION }}",

#               "chmod +x deployment/*.sh",
#               "bash deployment/deploy.sh ${{ secrets.DOCKER_USERNAME }} ${{ needs.build.outputs.image_tag }} ${{ secrets.DOCKER_PASSWORD }} green"
#             ]' \
#             --query 'Command.CommandId' \
#             --output text)
          
#           echo "command_id=$COMMAND_ID" >> $GITHUB_OUTPUT
#           echo " Command ID: $COMMAND_ID"

#       - name: Wait for deployment to complete
#         run: |
#           echo " Waiting for deployment..."
#           aws ssm wait command-executed \
#             --command-id ${{ steps.deploy.outputs.command_id }} \
#             --instance-id ${{ steps.launch.outputs.instance_id }}
          
#           echo " Deployment successful"
#       - name: Application health check
#         run: |
#           echo " Checking application health on localhost:80..."
          
#           HEALTH_CMD=$(aws ssm send-command \
#             --instance-ids "${{ steps.launch.outputs.instance_id }}" \
#             --document-name "AWS-RunShellScript" \
#             --comment "Health check instance 1" \
#             --timeout-seconds 120 \
#             --parameters 'commands=[
#               "for i in {1..5}; do",
#               "  if curl -f -s http://localhost:80 > /dev/null 2>&1; then",
#               "    echo \" Health check passed\"",
#               "    exit 0",
#               "  fi",
#               "  echo \"Retry $i/5...\"",
#               "  sleep 10",
#               "done",
#               "echo \" Health check failed\"",
#               "exit 1"
#             ]' \
#             --query 'Command.CommandId' \
#             --output text)
          
#           set +e
#           aws ssm wait command-executed --command-id $HEALTH_CMD --instance-id ${{ steps.launch.outputs.instance_id }}
#           EXIT_CODE=$?
#           set -e
          
#           if [ $EXIT_CODE -ne 0 ]; then
#             echo " Health check failed - terminating instance"
#             aws ec2 terminate-instances --instance-ids ${{ steps.launch.outputs.instance_id }}
#             exit 1
#           fi
          
#           echo " Application is healthy"

#       - name: Register to green target group
#         run: |
#           echo " Registering to green target group..."
#           aws elbv2 register-targets \
#             --target-group-arn ${{ env.GREEN_TG_ARN }} \
#             --targets Id=${{ steps.launch.outputs.instance_id }}

#       - name: Wait for health checks
#         run: |
#           echo " Waiting for health checks..."
#           aws elbv2 wait target-in-service \
#             --target-group-arn ${{ env.GREEN_TG_ARN }} \
#             --targets Id=${{ steps.launch.outputs.instance_id }}
          
#           echo " Instance is healthy"

#       - name: Set traffic to 20% green, 80% blue
#         run: |
#           echo " Setting traffic split: 20% Green, 80% Blue"
          
#           aws elbv2 modify-listener \
#             --listener-arn ${{ env.ALB_LISTENER_ARN }} \
#             --default-actions Type=forward,ForwardConfig="{
#               TargetGroups=[
#                 {TargetGroupArn=${{ env.BLUE_TG_ARN }},Weight=80},
#                 {TargetGroupArn=${{ env.GREEN_TG_ARN }},Weight=20}
#               ],
#               TargetGroupStickinessConfig={Enabled=false}
#             }"
          
#           echo " Traffic split configured"
#           echo " Blue: 80% (4 instances) | Green: 20% (1 instance)"

#   deploy-remaining-instances:
#     needs: [build, deploy-first-instance]
#     runs-on: ubuntu-latest
#     strategy:
#       max-parallel: 1
#       matrix:
#         instance_number: [2, 3, 4]
#     steps:
#       - name: Wait before next deployment
#         run: |
#           echo " Waiting ${{ env.WAIT_MINUTES }} minutes before deploying instance ${{ matrix.instance_number }}..."
#           sleep $((${{ env.WAIT_MINUTES }} * 60))
#           echo " Wait period complete"

#       - name: Configure AWS credentials
#         uses: aws-actions/configure-aws-credentials@v2
#         with:
#           aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
#           aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
#           aws-region: ${{ env.AWS_REGION }}

#       - name: Launch green instance
#         id: launch
#         run: |
#           echo " Launching Green Instance ${{ matrix.instance_number }}/${{ env.TOTAL_INSTANCES }}"
          
#           INSTANCE_ID=$(aws ec2 run-instances \
#             --launch-template LaunchTemplateId=${{ env.LAUNCH_TEMPLATE_ID }} \
#             --count 1 \
#             --subnet-id ${{ env.PRIVATE_SUBNET_ID }} \
#             --tag-specifications "ResourceType=instance,Tags=[
#               {Key=Name,Value=quotes-app-green-${{ matrix.instance_number }}},
#               {Key=Environment,Value=green},
#               {Key=DeploymentBatch,Value=${{ needs.build.outputs.image_tag }}},
#               {Key=InstanceNumber,Value=${{ matrix.instance_number }}}
#             ]" \
#             --query 'Instances[0].InstanceId' \
#             --output text)
          
#           echo "instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT
#           echo " Launched: $INSTANCE_ID"

#       - name: Wait for instance readiness
#         run: |
#           aws ec2 wait instance-running --instance-ids ${{ steps.launch.outputs.instance_id }}
#           aws ec2 wait instance-status-ok --instance-ids ${{ steps.launch.outputs.instance_id }}

#       - name: Deploy application
#         id: deploy
#         run: |
#           COMMAND_ID=$(aws ssm send-command \
#             --instance-ids "${{ steps.launch.outputs.instance_id }}" \
#             --document-name "AWS-RunShellScript" \
#             --comment "Deploy ${{ needs.build.outputs.image_tag }} - Instance ${{ matrix.instance_number }}" \
#             --timeout-seconds 1800 \
#             --parameters 'commands=[
#               "#!/bin/bash",
#               "set -ex",
#               "sudo mkdir -p /home/ubuntu/quotes-app/deployment",
#               "sudo chown -R ubuntu:ubuntu /home/ubuntu/quotes-app",
#               "cd /home/ubuntu/quotes-app",
#               "aws s3 cp s3://${{ env.DEPLOYMENT_BUCKET }}/deployments/${{ needs.build.outputs.image_tag }}/docker-compose.yml . --region ${{ env.AWS_REGION }}",
#               "aws s3 cp s3://${{ env.DEPLOYMENT_BUCKET }}/deployments/${{ needs.build.outputs.image_tag }}/deployment/ ./deployment/ --recursive --region ${{ env.AWS_REGION }}",
#               "aws s3 cp s3://${{ env.DEPLOYMENT_BUCKET }}/deployments/${{ needs.build.outputs.image_tag }}/quotes.conf . --region ${{ env.AWS_REGION }}",

#               "chmod +x deployment/*.sh",
#               "bash deployment/deploy.sh ${{ secrets.DOCKER_USERNAME }} ${{ needs.build.outputs.image_tag }} ${{ secrets.DOCKER_PASSWORD }} green"
#             ]' \
#             --query 'Command.CommandId' \
#             --output text)
          
#           echo "command_id=$COMMAND_ID" >> $GITHUB_OUTPUT
#           aws ssm wait command-executed --command-id $COMMAND_ID --instance-id ${{ steps.launch.outputs.instance_id }}
#       - name: Application health check
#         run: |
#           echo "ðŸ¥ Checking application health on instance ${{ matrix.instance_number }}..."
          
#           HEALTH_CMD=$(aws ssm send-command \
#             --instance-ids "${{ steps.launch.outputs.instance_id }}" \
#             --document-name "AWS-RunShellScript" \
#             --comment "Health check instance ${{ matrix.instance_number }}" \
#             --timeout-seconds 120 \
#             --parameters 'commands=[
#               "for i in {1..5}; do",
#               "  if curl -f -s http://localhost:80 > /dev/null 2>&1; then",
#               "    echo \"âœ… Health check passed\"",
#               "    exit 0",
#               "  fi",
#               "  echo \"Retry $i/5...\"",
#               "  sleep 10",
#               "done",
#               "echo \"âŒ Health check failed\"",
#               "exit 1"
#             ]' \
#             --query 'Command.CommandId' \
#             --output text)
          
#           set +e
#           aws ssm wait command-executed --command-id $HEALTH_CMD --instance-id ${{ steps.launch.outputs.instance_id }}
#           EXIT_CODE=$?
#           set -e
          
#           if [ $EXIT_CODE -ne 0 ]; then
#             echo "âŒ Health check failed - terminating instance"
#             aws ec2 terminate-instances --instance-ids ${{ steps.launch.outputs.instance_id }}
#             echo "âš ï¸ Keeping corresponding blue instance active"
#             exit 1
#           fi
          
#           echo "âœ… Application is healthy on instance ${{ matrix.instance_number }}"

#       - name: Register to green target group
#         run: |
#           echo " Registering instance ${{ matrix.instance_number }} to green TG..."
#           aws elbv2 register-targets \
#             --target-group-arn ${{ env.GREEN_TG_ARN }} \
#             --targets Id=${{ steps.launch.outputs.instance_id }}

#       - name: Wait for health checks
#         run: |
#           echo " Waiting for health checks..."
#           aws elbv2 wait target-in-service \
#             --target-group-arn ${{ env.GREEN_TG_ARN }} \
#             --targets Id=${{ steps.launch.outputs.instance_id }}
          
#           echo " Instance ${{ matrix.instance_number }} is healthy"

#       - name: Terminate one blue instance from target group
#         run: |
#           echo " Fetching instance from Blue Target Group..."
          
         
#           BLUE_INSTANCE=$(aws elbv2 describe-target-health \
#             --target-group-arn ${{ env.BLUE_TG_ARN }} \
#             --query 'TargetHealthDescriptions[0].Target.Id' \
#             --output text 2>/dev/null || echo "")
          
#           if [ -n "$BLUE_INSTANCE" ] && [ "$BLUE_INSTANCE" != "None" ]; then
#             echo "  Found blue instance: $BLUE_INSTANCE"
            
    
#             echo "Deregistering from target group..."
#             aws elbv2 deregister-targets \
#               --target-group-arn ${{ env.BLUE_TG_ARN }} \
#               --targets Id=$BLUE_INSTANCE
            

#             echo " Terminating instance: $BLUE_INSTANCE"
#             aws ec2 terminate-instances --instance-ids $BLUE_INSTANCE
            
#             echo " Blue instance terminated successfully"
#           else
#             echo "  No instances found in Blue Target Group"
#           fi

#       - name: Update traffic distribution
#         run: |
#           echo " Calculating new traffic distribution..."
          
#           # Count instances in both target groups
#           BLUE_COUNT=$(aws elbv2 describe-target-health \
#             --target-group-arn ${{ env.BLUE_TG_ARN }} \
#             --query 'length(TargetHealthDescriptions[?TargetHealth.State==`healthy` || TargetHealth.State==`initial`])' \
#             --output text)
          
#           GREEN_COUNT=$(aws elbv2 describe-target-health \
#             --target-group-arn ${{ env.GREEN_TG_ARN }} \
#             --query 'length(TargetHealthDescriptions[?TargetHealth.State==`healthy` || TargetHealth.State==`initial`])' \
#             --output text)
          
#           TOTAL=$((BLUE_COUNT + GREEN_COUNT))
          
#           if [ $TOTAL -eq 0 ]; then
#             echo "âŒ No instances found!"
#             exit 1
#           fi
          
        
#           BLUE_WEIGHT=$((BLUE_COUNT * 100 / TOTAL))
#           GREEN_WEIGHT=$((GREEN_COUNT * 100 / TOTAL))
          
#           echo "   Blue: ${BLUE_WEIGHT}% ($BLUE_COUNT instances)"
#           echo "   Green: ${GREEN_WEIGHT}% ($GREEN_COUNT instances)"

#           aws elbv2 modify-listener \
#             --listener-arn ${{ env.ALB_LISTENER_ARN }} \
#             --default-actions Type=forward,ForwardConfig="{
#               TargetGroups=[
#                 {TargetGroupArn=${{ env.BLUE_TG_ARN }},Weight=$BLUE_WEIGHT},
#                 {TargetGroupArn=${{ env.GREEN_TG_ARN }},Weight=$GREEN_WEIGHT}
#               ],
#               TargetGroupStickinessConfig={Enabled=false}
#             }"
#           sleep 20
#           echo " Traffic updated successfully"

#   approve-deployment:
#     needs: deploy-remaining-instances
#     runs-on: ubuntu-latest
#     environment: production-approval
#     steps:
#       - name: Approval gate
#         run: |
#           echo " All 4 instances deployed with new code"
#           echo " Manual approval required for final cutover"

#   complete-deployment:
#     needs: [build, approve-deployment]
#     runs-on: ubuntu-latest
#     steps:
#       - name: Configure AWS credentials
#         uses: aws-actions/configure-aws-credentials@v2
#         with:
#           aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
#           aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
#           aws-region: ${{ env.AWS_REGION }}

#       - name: Get all green instances from target group
#         id: green
#         run: |
        
#           GREEN_IDS=$(aws elbv2 describe-target-health \
#             --target-group-arn ${{ env.GREEN_TG_ARN }} \
#             --query 'TargetHealthDescriptions[*].Target.Id' \
#             --output text)
          
#           echo "green_ids=$GREEN_IDS" >> $GITHUB_OUTPUT
#           echo " Green instances: $GREEN_IDS"

#       - name: Get all blue instances from target group
#         id: blue
#         run: |
#           BLUE_IDS=$(aws elbv2 describe-target-health \
#             --target-group-arn ${{ env.BLUE_TG_ARN }} \
#             --query 'TargetHealthDescriptions[*].Target.Id' \
#             --output text)
          
#           echo "blue_ids=$BLUE_IDS" >> $GITHUB_OUTPUT
#           echo " Blue instances: $BLUE_IDS"

#       - name: Switch to 100% green traffic
#         run: |
#           echo " Shifting 100% traffic to green..."
          
#           aws elbv2 modify-listener \
#             --listener-arn ${{ env.ALB_LISTENER_ARN }} \
#             --default-actions Type=forward,TargetGroupArn=${{ env.GREEN_TG_ARN }}
#           sleep 20
#           echo " 100% traffic on green"

#       - name: Terminate all remaining blue instances
#         if: steps.blue.outputs.blue_ids != ''
#         run: |
#           echo " Terminating remaining blue instances..."
          
#           for INSTANCE_ID in ${{ steps.blue.outputs.blue_ids }}; do
#             echo "Deregistering: $INSTANCE_ID"
#             aws elbv2 deregister-targets \
#               --target-group-arn ${{ env.BLUE_TG_ARN }} \
#               --targets Id=$INSTANCE_ID || true
#           done
          
        
          
#           echo " Terminating instances..."
#           for INSTANCE_ID in ${{ steps.blue.outputs.blue_ids }}; do
#             aws ec2 terminate-instances --instance-ids $INSTANCE_ID
#             echo "Terminated: $INSTANCE_ID"
#           done

#       - name: Promote green to blue
#         run: |
#           echo " Promoting green instances to blue..."
          
#           for INSTANCE_ID in ${{ steps.green.outputs.green_ids }}; do
#             aws ec2 create-tags \
#               --resources $INSTANCE_ID \
#               --tags Key=Environment,Value=blue
            
#             aws elbv2 register-targets \
#               --target-group-arn ${{ env.BLUE_TG_ARN }} \
#               --targets Id=$INSTANCE_ID
            
#             echo " Promoted: $INSTANCE_ID"
#           done
#       - name: Wait for all targets healthy in blue
#         run: |
#           echo " Waiting for all targets to be healthy in blue TG..."
#           sleep 20 
    

#       - name: Switch listener to blue
#         run: |
#           echo " Switching listener to blue target group..."
          
#           aws elbv2 modify-listener \
#             --listener-arn ${{ env.ALB_LISTENER_ARN }} \
#             --default-actions Type=forward,TargetGroupArn=${{ env.BLUE_TG_ARN }}
#           sleep 2
#           echo " Listener now points to blue TG"

#       - name: Cleanup green target group
#         run: |
#           echo " Cleaning up green target group..."
          
#           for INSTANCE_ID in ${{ steps.green.outputs.green_ids }}; do
#             aws elbv2 deregister-targets \
#               --target-group-arn ${{ env.GREEN_TG_ARN }} \
#               --targets Id=$INSTANCE_ID || true
#           done

#       - name: Deployment summary
#         run: |
#           echo "All instances running latest code in Blue TG"
